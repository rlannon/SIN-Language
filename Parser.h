#pragma once

#include <vector>
#include <tuple>
#include <string>
#include <list>
#include <algorithm>
#include <iostream>
#include <fstream>
#include <regex>
#include <memory>

#include "Statement.h"

/*

The Parser class takes a stream of tokens generated by the Lexer and constructs and abstract syntax tree from them. For reference on how the abstract syntax tree is constructed, see "ast" in the Doc folder.

NOTE:
	Add in a function to allow the stream to be read in from a json file

*/


class Parser
{
	std::ifstream* token_stream;	// a stream of tokens to be parsed

	typedef std::tuple<std::string, std::string> lexeme;
	typedef std::tuple<std::string, std::string> ASTNode;

	std::vector<lexeme> tokens;
	int current_token;
	int num_tokens;

	std::vector<ASTNode> AST;

	void populate_tokens_list();

	bool quit;
public:
	static const std::vector<std::tuple<std::string, int>> precedence;	// a vector containing tuples of all operators and their precedences
	int get_precedence(std::string symbol);	// returns the precedence of a given operator; if no such operator exists, returns -1

	// Some utility functions
	bool is_at_end();	// tells us whether we have run out of tokens
	lexeme peek();	// get next token without moving the position
	lexeme next();	// get next token
	lexeme current();	// get token at current position
	lexeme previous();	// similar to peek; get previous token without moving back
	lexeme back();	// move backward one
	void error(std::string message, int code);

	// Parsing functions

	// determines what to parse based on the current token in the stream
	void skip_punc(char punc);	// skips the specified punctuation mark
	void parse_top();
	Type get_type(std::string candidate);

	// Parse statements
	std::unique_ptr<Statement> parse_statement();	// return a unique_ptr to a Statement (which can contain a derived class from Statement)
	std::tuple<Type, std::string> parse_allocation();
	std::tuple<LValue, std::shared_ptr<Expression>> parse_assignment();	// return an assignment as a tuple of its values

	// Parse expressions
	std::shared_ptr<Expression> parse_expression();	// Expression has derived classes, so use a pointer to an expression like we do for Statement
	std::tuple<std::shared_ptr<Expression>, exp_operator> parse_unary(lexeme op_char);	// parse a unary expression

	bool is_binary(int position);	// looks around the character at "position" to tell us whether the left operand of the binary expression to be made should be this token or a binary expression using this and another token
	std::shared_ptr<Binary> maybe_binary();
	std::tuple<std::shared_ptr<Expression>, std::shared_ptr<Expression>, exp_operator> parse_binary(std::shared_ptr<Expression> left_exp);	// parse a binary expression

	// to overload our operator and allow reading of tuples to be done with an ifstream object
	std::istream& read(std::istream& is);

	Parser(std::ifstream* stream);
	~Parser();
};

std::istream& operator>>(std::istream& is, Parser& parser);
