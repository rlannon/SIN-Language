COMMIT_HISTORY.TXT

A list of changes made since last git commit. This file will go into more detail about the changes than the commit text will.
This file now contains a history of changes.

--------------------------------------------------------------------------------------------

3/18 commit to Compiler

- Compiler functions no longer take 'size_t* stack_offset' as an argument; it is now a member variable of Compiler because it is used so often.
- Void functions are now required to have a return statement -- this may either be "return" or "return void". The 'return' statement is what unwinds the stack, and so failing to include one will result in data corruption. The compiler will generate a warning if the last statement is a function is not a return statement, but not if no return statement is present.
- Fixed a parser bug that didn't correctly parse conditionals without 'else' clauses
- Fixed logical errors in the SINVM mult and div instructions. Previously, it was treating numbers as signed as long as ((A == signed ) && (B == signed)) evaluated to false; that means if the sign bit in both numbers were clear, it treated the result as signed (essentially because we were using OR logic, not XOR logic). This has been resolved; the result is treated as unsigned as long as the sign bits in both A and B match. If they do not, this means only one number is signed, so we have to perform two's complement.
- Further, some boolean comparisons needed parens in the SINVM mult/div instructions due to precedence rules that were overlooked.

--------------------------------------------------------------------------------------------

3/17 commit (3) to Compiler

- Changed the algorithm to evaluate binary trees to start evaluation from the left side rather than the right; this allows for string concatenation to be done (evaluating from right is fine for integer expressions, but once we start writing data in the buffer, it must be done from left to right if there are more than two or three strings to concatenate together).

--------------------------------------------------------------------------------------------

3/17 commit (2) to Compiler

- The VM now uses list::insert to add items upon dynamic memory allocation instead of using list::push_back and list::sort; this is less computationally expensive (O(n) vs O(n log n)). The heap objects will still be in order of where they are in memory.
- Renamed the input buffer in the VM memory map to be a string buffer instead; this is a little more appropriate as it is a buffer for working with strings.
- Implemented string concatenation. The compiler uses the string buffer for this purpose, utilizing __builtins_memcpy to copy each part of the binary tree into the buffer before copying the buffer back into the variable.
	- Note there is still a bug if there are more than two arguments in concatenation. This will be resolved in the next commit.
- Fixed a bug in dynamic reallocation; accidentally used < in a comparison to _HEAP_MAX when it should have been <=
- Added a feature to VMExceptions that includes the state of the STATUS register

--------------------------------------------------------------------------------------------

3/17 commit to Compiler

- Merged Arrays into Compiler
- Implemented dynamic memory reallocation
- Compiler::string_assignment() no longer allocates a new string every time; if the string has already been allocated (Symbol::allocated), it uses the reallocate syscall.

--------------------------------------------------------------------------------------------

3/14 commit to Arrays

- Updated precedence vector to reflect changes to the tokens and operators list
- Updated the translate_operator function (in Expression.cpp) to reflect changes to the operators; further, modified code to avoid aborting the 'for' loop and returning NO_OP at the end of the function only if the loop is never aborted
- Added mult, multu, div, and divu instructions to the VM for multiplication and division; as such, removed __builtins_mult and __builtins_div from the builtins-sinasm16 library.
- In order to determine whether a value is signed or not (as it needs to know for mathematical operations), 'SymbolQuality' now has 'SIGNED' and 'UNSIGNED' qualities. This allows us to determine what instructions to use / how to proceed based on whether we need to treat data as signed or not
- Added a function to the compiler to determine whether an expression is signed:
	- For ints, if the quality is not specified, it's signed
	- Floats are always signed
	- Literal ints are only signed if they are < 0
- Note that although right now, signed/unsigned ints are all treated as the same type, it may be easier to implement separate signed int/unsigned int types if it is the only type that can be unsigned
- Added a 'compiler_warning' function to print a compiler warning -- these are things encountered in compilation that will not stop compilation, but could cause undefined bevahior if they aren't handled (things like signed/unsigned mismatches will go here)
- Fixed parser bug that would crash program if there was an empty function definition; it now prints a warning, but still parses. The compiler will also print a warning if it comes across an empty function definition

--------------------------------------------------------------------------------------------

3/9 commit (2) to Arrays

- Designed compiler schemes to fetch and assign indexed variables
	- Added comments to explain how these algorithms work
- Added _RS_END marker to the VM Memory Map and updated the reference to the _RS data section in the Linker (this way, whenever the VM Memory Map is updated or changed, the linker will still be able to link files using the proper map)
- Updated SINC format to include the symbol width in the symbol table data (_sy_width)
- Updated the builtins library to use the new @rs syntax
- Arrays may now not hold other arrays or structs; however, they may hold pointers to such objects. Arrays may also not use alloc-assign syntax for the time being
- Began process of removing unnecessary variables; most of this happens in the SinObjectFile, Linker, and Assembler classes in reference to symbol, relocation, and data table members. Now that structs are being used for such data, some variables used by these classes are unnecessary and will be removed.
- Modified the SINVM::_debug_values function to display the first page of the stack beneath the memory data

--------------------------------------------------------------------------------------------

3/9 commit to Arrays

- Updated Assembler, SinObjectFile, and Linker to use 'typedef struct' for the symbol, data, and relocation tables rather than tuples. Tuples were a poor choice for the task and structs are far more appropriate. They make the code easier to read, less error-prone, and more maintainable.
- Some initial array implementation; this is far from complete and will be improved and expanded upon in further commits to this branch.
- Removed 'CompilerException' from the repository; the files were unused as such exceptions are now in the 'Exceptions' files.
- The SINASM @rs directive now requires the number of bytes to reserve for the given macro
- Fixed a bug in SINASM that occurred when using indexed addressing with labels; the comma (because commas are required in the indexed addressing syntax in SINASM) was being pushed as a part of the symbol name to the relocation table, so the linker threw an error when it couldn't find the appropriate symbol to match. Now, the assembler removes said comma before pushing to the relocation table, and the error has been fixed.

--------------------------------------------------------------------------------------------

3/4 commit to Compiler

- The parser will now throw exceptions when:
	- It doesn't see an = sign in an assignment
	- The ends of allocation statements don't end with a semicolon, comma, or closing paren (the latter are for function definitions)
- Added an 'AssemblerException' class; replaced runtime_error in Assembler class with this exception
- The 'RAW' type no longer requires (or accepts, for that matter) the size of the raw variable; it defaults to the word size of the machine. In future, it will accept "short" and "short short" (or "long" and "long long") to modify its size
- Added a 'sizeof' expression type to return the size (in bytes) of a type
- Implemented the 'short' addressing mode in the Assembler and SINVM to address a single byte of the memory, rather than a whole word (used for load/store instructions only at the moment)
	- Updated the __builtins_memcpy subroutine to use _bytes_ rather than _words_ for length of memory to copy
	- Added mirrored addressing modes for the short types (i.e., absolute is 0x00, short absolute is 0x10; x indexed is 0x01, short x indexed is 0x11)

--------------------------------------------------------------------------------------------

3/2 commit to Compiler

- Merged Dynamic-Memory into Compiler and deleted the former
- The software is now licensed under the MIT License
- Removed scope information from the 'Statement' class; they were unused and unnecessary
- Input data can no longer cause a buffer overflow into the stack; if the input data is larger than the input buffer, the VM will only copy in as many bytes as are available to the buffer.
- Fixed error where the program threw an std::vector exception when certain lines went unfinished; the Parser::next() and Parser::peek() methods checked to see if the position was <= to the size of the token list when they should have only checked to see if it was <
- Empty tokens are now deleted from the tokens list when the Parser is initialized with a Lexer object
- The SymbolTable::lookup(...) and SymbolTable::is_in_symbol_table(...) functions previously only looked for symbols with the same name that were /also/ in the same scope; the functions now look at lower scopes as well
- Added 'bool SymbolTable::exists_in_scope(...)' to check to see whether a given variable exists in the specified scope at the specified scope level; this is used by the 'SymbolTable::insert(...)' function to check and make sure we don't have duplicates. This is different from SymbolTable::is_in_symbol_table because the latter simply checks to make sure we aren't going to be looking up a symbol that doesn't exist.
- Added "SymbolTableException" class
- Added "line number" as a parameter to the SymbolTable::insert functions; added line numbers to calls for SymbolTable::insert(...) in the Compiler class
- Minor updates to some of the /Doc files

--------------------------------------------------------------------------------------------

2/28 commit (2) to Dynamic-Memory

- Moved the "Symbol" struct to its own file, which is included in the project through the SymbolTable files.
- Began process of adding comment headers to each of the files with short descriptors of what the files' purposes are.
- Changed more exceptions from runtime_error to an exception of the appropriate type (currently using error code 0 as a placeholder)
- Dynamic memory can now be freed using the "free" keyword
	- 'Statement' now contains a 'FreeMemory' statement type
	- The Parser can now parse 'free ...' statements
	- The Compiler can generate assembly for such statements
	- Note that nothing is automatically freed right now and strings must be freed manually (they are _always_ dynamically allocated)
- Reserved a few more keywords for things that will be implemented in future commits (such as arrays and structs)

--------------------------------------------------------------------------------------------

2/28 commit to Dynamic-Memory:

- Implemented global and local strings, both of which can be used in function calls.
	- Currently, the string memory is not freed and there is no mechanism for strings to be reallocated when necessary. Automatic memory reallocation must be expanded and refactored, alongside compiler refactoring, to allow strings to be automatically reallocated when their size expands beyond the space initially allocated for it. Further, the compiler still needs a mechanism to automatically free string memory when they go out of scope.
	- The compiler and parser also need methods to free memory and dynamically allocate memory beyond strings.
- Updated the Compiler::call method to be cleaner and more maintainable, in particular in the way function arguments are pushed to the stack, especially differentiating between static/automatic and dynamic memory.
- Modified the Compiler::incsp_to_stack_frame method to be far more general and flexible; it moves the stack pointer to a particular offset, not just the end of the stack frame.
- Added a string assignment function to handle initial assignments to strings.
	- It must be updated so that it does not reallocate memory for each assignment, and only reallocates the string when necessary.
- Fixed a small bug in the compiler where the string length was not correctly loaded from the heap; it treated certain data as a double-reference pointer when it was only single-reference. The change was from using indirect indexed addressing to plain indexed.
- The VM now forbids writing data into address 0x00; this is so that null pointers will always be guaranteed to return 0x00.
- Added more comments, made further minor fixes to code and readability

--------------------------------------------------------------------------------------------

2/21 commit to Dynamic-Memory:

- 'int main(...)' now supports command-line arguments; no longer throws exceptions when they are supplied
- Began implementation of string support in compiler through the newly-added dynamic memory allocation
- Added an 'INCB' instruction to the VM's instruction set; there is no corresponding 'DECB' instruction
- Added a '__builtins_memcpy' subroutine to 'builtins-sinasm16' and a corresponding SIN wrapper for the memcpy(...) function.
- Fixed an error in the Exceptions wherein error messages from 'what()' were not printed; this was due to a pointer invalidation as a result of using variables in the virtual function, which were destroyed by the time the function was invoked. Moving all message constructions into the constructor for the exception solved this issue.

--------------------------------------------------------------------------------------------

2/20 commit to Dynamic-Memory:

- Added a 'DynamicObject' class, to be used by the VM to store information about dynamic objects, and added a list of such members to the VM
- Added the syscall instructions necessary for reserving VM Heap memory
	- See syscall.txt for information on how they work
- Updated the VM memory map with new address spaces and names
- Fixed data bug in Assember that caused it to write incorrect data for addresses
- 'syscall #$14' no longer encloses the output string in double quotes
- AddressingModeConstants includes <cinttypes>, not <iostream> for the uint__t types
- Other minor edits, fixes, and commenting

--------------------------------------------------------------------------------------------

2/20 commit to Compiler:

- Changed github username, so made changes in the code to reflect that (where github was mentioned).
- Changed SINVM registers from 'int' to 'uint16_t' -- this more accurately reflects how the inner workings of this processor are supposed to be.
- Removed old 'Assembler::disassemble()' code, as the .sinc format has changed since that code was written and the disassemble code was never updated. The function will be rewritten in a future commit.
- Refactored some of the code to make initial assignments to constants. It is still incomplete but will be completed in future commits.
- Added a 'CompilerException' class; all compiler exceptions will be modified to this type in future.
- Began implementation of a 32-bit (single precicion) float type, though this may be changed to 16 bits (half-precision) depending on how it is ultimately implemented in the VM.
- Moved the various enumerated types into their own file for better maintainability / overall organization.

--------------------------------------------------------------------------------------------

2/17 commit to Compiler:

- Fixed more bugs in the builtins mathematical functions and implemented signed multiplication
	(bugs being not getting the correct number when multiplying)
- Fixed a bug in the SINVM code that resulted in an incorrect number being outputted in the load_data_from_memory() function -- switched from a for loop with one index variable to a while loop with 2, which solved the issue
- Fixed some bugs relating to pointers in the compiler -- specifically:
	1) the compiler would report a type match error when the rvalue of an assignment had a pointer in it (specifically in binary rvalue expressions)
	2) the compiler could not properly use dereferenced pointer values as it did not distinguish between pointers and non-pointer lvalues; it can now properly make such references as the indirect addressing modes exist in the assembler
- Fixed pointer dereferences in Parser -- double-ref pointers ended up breaking in the Parser; this is no longer the case, as the method implemented here seems to be more robust than the previous way
- Refactored the Parser to use many functions instead of a single large one to parse statements
- Changed the "lvalue" variable under Statement::Assignment to be a shared pointer rather than an LValue; this allows the left hand expression to be a dereferenced pointer
- Implemented indexed indirect and indirect indexed addressing modes in the VM
- Added an 'f' flag in the STATUS register to indicate a floating point number
- Cleaned up code, added more comments
- Addressed some of the compiler warnings, particularly those about signed/unsigned mismatches (there was a discrepancy between types -- most notably, comparing size_t and int)

Notes:
	- The code currently cannot handle double ref pointers; this is something that will be added in future. Single ref pointers are OK so far
	- There are yet more bugs to fix and there will always be more code to clean up; future commits will include more fixes, refactoring, and comments
	- The 'builtins' functions for mathematics are not yet complete; the library will be expanded in future commits
	- The main function is inefficient and the current methods for use of flags do not work if you wish to use multiple at a time; the main function will therefore be refactored in a future commit to be more modular and efficient.

--------------------------------------------------------------------------------------------

2/15 commit to Compiler:

- Began process of implementing mathematical functions via the 'builtins' library
- There was previously a bug where labels were not given the correct address upon assembly; this was due to an oversight in the code where using a register addressing mode would increment the byte counter too far (instead of incrementing it two bytes for 'ADDCA B', it would add the wordsize on top, resulting in overshooting the destination by 2 bytes per register-operand instruction). This has been fixed.
- Began process of implementing binary tree evaluation, though it is far from complete. There are still many known bugs and incomplete sections of the code.

--------------------------------------------------------------------------------------------

2/13 commit to Compiler:

- Implemented preliminary code to compile if/then/else (ITE) statements
- Added a routine to handle unary expression evaluation
- Added 'sen' and 'cln' (set negative and clear negative) opcodes into SINASM
- Modified some operations within the SINVM to set flags when said operations are performed (e.g., addition can now set the N flag)
- Local variables are now assigned correctly in the assign function -- rather than using the symbol name, it uses the stack (as it is supposed to)
- Branching to an ITE now updates the scope name to be __ITE_<branch number>
- If branches can now be created without an accompanying else branch in the compiler
- More comments and minor other fixes

--------------------------------------------------------------------------------------------

1/21 commit to Compiler:

- There was a previously unknown bug in the Parser wherein dereferenced pointers would result in errors if they were a part of a binary tree. This has been resolved; in parseExpression, we were returning the dereference object directly rather than passing it into maybeBinary, which is what we should have been doing.
- Refactored the compiler's assignment routine to use our new function to fetch values. Note that pointers and dynamic memory types have not yet been implemented.
- More comments and minor other fixes.

--------------------------------------------------------------------------------------------

1/17 commit to Compiler:

- Because gcc/g++ does not support 'std::exception' initialized with a string or char*, all instances of "throw std::exception(" ... ")" were changed to "throw std::runtime_error("...")" for cross-compiler support.

--------------------------------------------------------------------------------------------

1/16 commit to Compiler:

- Added support in assembler for indexed indirect addressing modes alongside indirect indexed; syntax is the same as in 6502 assembly
- Refactored the data type system to support primary- and sub- types alike; this included major changes to the Interpreter as well as some changes in the Expression and Statement classes
- Changed Interpreter's symbol table system to use a 'typedef struct' for symbols instead of 'std::tuple'
- Made some changes to begin the project of dynamic memory management in the compiler/assembler/etc.; non-const-qualified strings will require dynamic memory on the heap, whereas the current system supports only static/const memory
- Removed some old and unnecessary code

--------------------------------------------------------------------------------------------

1/14 commit to Compiler:

- Renamed the namespace 'addressmode' to 'addressingmode' as it is more accurate/consistent
- Refactored statement::type and expression::type to use enums instead of strings; this allows for code that makes much more sense to read, as well as a much more limited range of choices for the types of statements and expressions we can use (e.g., no more wondering if it is "lvalue" or "LValue", as it is LVALUE)
- Began adding in support for a "builtins" library in the compiler (built-in functions will not be hard-coded in the compiler, but use assembly implementations in separate files that are included in projects)
- Added a vector of already-included libraries so we can avoid duplicate dependencies, though it is not yet fully implemented or well-tested
- Added more compilation routines, though they are nowhere close to finished and the compiler remains largely incomplete
- Many more comments
- Began work to make the functions more modular and maintainable
- Fixed typos
- Removed some unnecessary stuff
- Changed comments from # to // in SIN
- Added "asm<>" keyword for inline ASM; note this is NOT protected and the compiler essentially ignores what you do inside
- Updated the included "BinaryIO" library to its latest version

According to "cloc", the project now contains approximately:
	- 5600 lines of code
	- 1700 comment lines
	- 1600 blank lines

--------------------------------------------------------------------------------------------
1/5 commit to Compiler:

- Added constants for the addressing modes in assembler/SINVM. Now, address modes can be referenced by addressmode::___ instead of a number. This makes for less obfuscated and more maintainable code.

- Added beginning to the compiler. Currently capable of producing simple allocations and assignments (literals only) as well as function definitions.

- Modified the 'lexeme' typedef to be a 'typedef struct' instead of an alias for tuple<string, string>. As such, all references to lexemes were modified (and are now much more readable and maintainable). Further, 'int line_number' was added so that the line number where the lexeme was found is included.

- Added a line counter to the Lexer; every time we call next(), if the character is \n, the counter is incremented.

- Added a line number variable to the Statement class, which uses the line number of the first lexeme in the statement to determine the line on which the statement occurred. This allows the compiler to show what line errors occurred on.

--------------------------------------------------------------------------------------------
12/31 commit to Assembler-Directives:

- Changed assembler labels; they no longer begin with "." unless it is a sublabel. Sublabels are always in reference to the most recent "global-level" loop above them. For example:
	MyLabel:
		... 
	.loop:

This will create two labels in the symbol table:
	MyLabel
	MyLabel.loop
Referencing .loop underneath "MyLabel" will look for "MyLabel.loop".

- Because of this, the "is_label()" function was modified to look for a colon at the end of the label rather than a period at the start.

- Added macro support. While label and constant values will be updated by the linker, macro values will not; this is because macro values, when set, are set to a specific value. As such, they should remain unchanged. This is achieved through the sue of another symbol class, "M"

- Modified the values corresponding to the various symbol classes.

--------------------------------------------------------------------------------------------

12/28 commit to Assembler-Directives:

- Updated main program so that it's cleaner and has better support for flags

- Added processor directives:
	- @db - define a constant
	- @rs - reserve memory space (not fully implemented)
	- @include - include a file

This entailed:
	- Updating the linker and adding "C" and "R" classes
	- Updating the assembler
		- Pass 1 now processes all assembler directives; pass 2 ignores them
		- Pass 1 now does what pass 2 does to parse lines -- it creates an array of strings, delimited by spaces
	- Updating the SinObjectFile class
	- Updating the SINVM

Further:
- Began work on the compiler proper
- Added a SymbolTable class for use in the compiler's symbol tables
- Bug fixes
- More comments
- Added includes to SIN files, which required updating the Lexer and Parser classes

Note there are many "TODO:" comments in the code. One major area of focus next is the disassemble function in the Assembler class; it must be updated to support the new .sinc format. These "TODO:" comments will be addressed in future commits.

--------------------------------------------------------------------------------------------

- "changelog.txt" renamed to "commit_history.txt"

- Changed `uint8_t* PC` to `uint16_t PC`; the program counter now holds a memory address in the VM instead of a pointer to the address within the C++ program. This allows us to use a call stack and more easily move around in our program memory. As such, all control flow instructions were modified.

- All pointers were changed to uint16_t type instead of size_t or uint8_t*

- Added the class that will implement our compiler

- Added a memory map

--------------------------------------------------------------------------------------------

12/19:

- Added changelog file; this file's purpose is to log changes as they are made and to go into greater depth about the changes that were made and /why/ they were made.

- Moved all of the opcode constant definitions into "OpcodeConstants.h", which is included in "Assembler.h". The point of this is to:
	- Declutter the Assembler header file
	- Keep the code more organized and maintainable

- Changed "void SINVM::execute_load(int* reg_target)" to "int SINVM::execute_load()"; there is no good reason to have it modify an integer via pointers when it can just return one. While modifying the integer may be emblematic of some other programming style, there is no point to doing it this way so it was changed to return an int.

- Added more comments to code in order to make it more readable

- Simplified some expressions throughout in an attempt to clean up the code

- Added macro support in the assembler. The assembler will parse all macros in the second pass. Unlike labels, macros cannot be referenced before assignment/declaration (much like variables in SIN). This is because labels get their own pass in the assembler to be added; macros are parsed on the second pass. This allows them to be changed after their use.

- Added a disassemble function. Given a SIN bytecode / compiled SIN file, it will produce a SINASM file of a given name based on the compiled file supplied. Note that labels and macros are NOT preserved.

- Moved the function to load a .sinc file into its own file; because it is referenced by both the Assembler and the SINVM, it should be accessible to both in one file, rather than having duplicate definitions in separate files. And, because no instance of the Assembler is opened within the SINVM, it made the most sense to move it into its own file.
