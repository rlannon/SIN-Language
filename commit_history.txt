COMMIT_HISTORY.TXT

A list of changes made since last git commit. This file will go into more detail about the changes than the commit text will.
This file now contains a history of changes.

--------------------------------------------------------------------------------------------

9/5 commit to master

- Fixed some compiler warnings (mostly regarding signed/unsigned mismatches, control paths, etc.)
- Implemented dynamic memory to some extent; it is still messy and will require /a lot/ of refactoring, but the proof of concept is there
	- Split allocation function into multiple functions that execute depending on the type of allocation taking place
- 'free' now works on pointers that reference dynamic memory
- Added a "SymbolQualities" class to hold the quality data for a symbol; this is easier than iterating through a vector every time, as it contains booleans. Vector iteration only happens in the constructor or if qualities need to be added.
	- As a result, the 'Definition' statement type was modified, as was all code relating to its construction
	- Further, all code to fetch symbol qualities was changed; vector iterations are no longer needed but the local boolean variables containing this data are still used so we can see "is_const" rather than "symbol->type_information.get_qualities().is_const
- General code cleanups and comment updates

--------------------------------------------------------------------------------------------

8/1 commit to master

- Added Parser::has_return to recursively determine whether a given StatementBlock object contains a return statement. This is used to check to ensure function definitions return a value. Further, the compiler also checks to ensure the data type of the expression being returned matches the function's return type
- Implemented DataType class, replacing TypeData; it is to be used in place of all references to type/subtype combo
- Implemented more type-checking through the use of the DataType class
- Fixed some bugs in parser and compiler; particularly, fixed a bug that would crash the program on certain invalid characters. Further, compiler now gives more descriptive error message if something like 'let $myVar = ...' is found (previously, no code existed to handle address-of operators in lvalues)
- BRK instruction now executes in the VM; it is a temporary breakpoint instruction that will be removed once the debugger is implemented

--------------------------------------------------------------------------------------------

7/17 commit to master

- Made stack reading/writing cleaner and more modular, particularly with operations using the call stack (implemented push/pop functions for the call stack)
- Fixed pointers and how they are handled both in static and automatic memory -- multiple dereferences work in both scopes for both fetching and writing values
- Began work on modularizing the assignment function in the compiler; various types of assignments will be handled by different functions to break up the old function, which was getting pretty massive
- Implemented a function to check whether two types are compatible; this takes two expressions and determines whether they can be used together (this is better than checking whether the types are equal to subtypes and so on)
- Implemented four new instructions, PRSA/B, RSTA/B -- for preserving and restoring A/B on the call stack, respectively

--------------------------------------------------------------------------------------------

7/14 commit to master

- Changed occurrences of int to size_t, unsigned int, and uint_t where appropriate (C++ standard int is rarely necessary in this project). These changes occurred mostly in the assembler and linker as well as the various data structures we use to track data within them.
- Moved pack_32 and unpack_16 to its own library -- it is used in a few different places, so they're useful as utility functions
- Fixed SINVM::address_is_valid logic -- it was previously checking an impossible condition
- Fixed some FPU floating point arithmetic evaluation bugs
- Began implementation of the "float" type in the compiler; this is currently a half-precision floating-point type
- Implemented PRSR (PReServe Registers) and RSTR (ReSTore Register) instructions; values are preserved on the call stack
- Changed SINVM::STATUS from uint8_t to uint16_t; this will allow more flags should we need them

--------------------------------------------------------------------------------------------

7/13 merge Compiler, VM into master

--------------------------------------------------------------------------------------------

7/12 commit to VM

- RTS was previously not listed as a standalone opcode; this caused an exception to be thrown by vector because the assembler expected something after. This has been resolved.
- Reorganized the SINVM::execute_instruction function to reflect the new order of instructions in OpcodeConstants.h
- Began implementation of some new instructions
- Eliminated code for BRZ instruction; it now uses the same code was BRNE (they both test the Z flag)
- Began implementation of FPU class:
	- Supports 16-bit and 32-bit precision
	- 16-bit functions convert to a 32-bit float, perform the operation in 32-bit, and convert back
	- 32-bit instructions currently not implemented, as a method to load 32-bit values from memory must be implemented first

--------------------------------------------------------------------------------------------

7/10 commit to VM

- Implemented signals in VM; replaced most VM exceptions with them; if left unhandled, however, the signals will generate VM exceptions
- Added a RESET signal, which is generated by the RESET function
- Tweaked VM Memory Map
- Split up the VM implementation across multiple source files in order to make it more readable and maintainable
- Began implementation of some of the new processor instructions
- Added SUBCA and SUBCB instructions, as those were missing in the previous commit

--------------------------------------------------------------------------------------------

7/9 commit to VM

- Modified opcode constants to fit the new scheme; they are organized in a more logical manner than before
- Further, the following assembly instructions were added:
	- TBX, TXB, TBY, TYB - transfer B to X and vice versa; B to Y and vice versa
	- TBSP, TSPB; TXSP, TSPX; TYSP, TSPY - transfer B, X, Y to the Stack Pointer, and vice versa 
	- TBSTATUS, TSTATUSB - transfer B to the STATUS Register, and vice versa
	- INCM, DECM - increment/decrement value at a memory location
	- BRN - branch on negative
	- BRPL - branch on plus
	- IRQ - Interrupt request
	- RTI - Return from interrupt
	- RESET - Resets the program counter and stack pointers without clearing memory
	
	Note that space has been reserved for floating point instructions once the floating point unit is implemented
- Began adding support for an indirect addressing mode; this is a simple pointer and does not use X/Y registers
- Began the process of implementing processor signals:
	- SINSIGFPE		-	mathematical error
	- SINSIGSYS		-	system call error (bad arguments)
	- SINSIGILL		-	illegal instruction
	- SINSIGSTKFLT	-	stack fault (overflows/underflows)
	- SINSIGSEGV	-	segmentation violation
	- SINSIGKILL	-	kill signal
- Began process of using named constants for syscall numbers in order to make things more readable and maintainable

--------------------------------------------------------------------------------------------

7/1 commit to Compiler

- Added support for initializer lists for arrays
- Removed "Interpreter" class, as it was very out-of-date and poorly-written
- Added a routine in the Compiler::get_expression_data_type function to get the type of a List expression and validate that the list is homogeneous
- sizeof expressions now use angle brackets instead of parens (e.g., 'sizeof<int>'); this is because sizeof should not be thought of as a function, but as a keyword, and angle brackets are therefore more appropriate.
- Moved many function implementations for the Parser class from Parser.cpp to ParserUtil.cpp, as they are more appropriately placed there
- Minor code and comment fixes

--------------------------------------------------------------------------------------------

5/21 commit to Compiler

- Assembler now puts the length of const strings before the string data when the @db directive is used
- Modified how string constants and const strings are fetched in Compiler::fetch_value(...) to reflect the new structure of how constants are allocated in program memory with @db directive
- Modified how const variables are initialized in the global scope; they may not be initialized with pointers and the values that are used to initialize constants must be able to be determined at compile time
	- Note local variables currently are only allowed to be initialized with constants
- Modified how strings are pushed to functions so that they only take up one word -- rather than pushing the length and address, it only pushes the address
- Modified the 'builtins' library so this new string parameter handling is supported
- Changed boolean constants from 'True' and 'False' to 'true' and 'false' (from Python style to C style)
- Moved some functions into a 'CompilerUtilites.cpp' file for organization purposes
- Modified 'builtins-sinasm16.sina' to use a constant address for the input length -- this allows us to return the address of _INPUT_LEN as the string start

--------------------------------------------------------------------------------------------

5/5 commit to Compiler

- Added support for postfixed symbol qualities, using the following syntax:
	alloc/decl <type> <name> &<quality>
	alloc/decl <type> <name>: <expression> &<quality>
- Continuing process of breaking the Parser implementation into multiple files
- Added a function to the Parser to get the appropriate SymbolQuality given a lexeme
- Added a function to the Parser to generate a vector<SymbolQuality> when the qualities given are postfixed
- A bug was discovered in const data members (particularly strings) due to the generated assembly. An assembler overhaul is long due and this issue will be revised (at least partially) in the process.
	
--------------------------------------------------------------------------------------------

5/4 commit to Compiler

- Modified 'Symbol':
	- No longer uses 'typedef struct'; it is simply a struct
	- Removed formal_parameters
- Added 'FunctionSymbol':
	- Child of 'Symbol'
	- Has a formal_parameters member

	Note polymorphism is being used because it simply doesn't make sense for every variable to have a member 'formal_parameters'. Polymorphism will also be used as such when it comes time to implement structs; there will be a StructSymbol class to contain the appropriate data about a particular struct type

- As such, the SymbolTable class was modified for the newly added polymorphism. Table members are now shared_ptr objects
- Added an enum 'SymbolType', and 'Symbol' now contains a member of such type; it is similar to stmt_type and exp_type in that it allow us to make distinctions between the various types of Symbols, so we can behave appropriately based on the type of Symbol we have
- Because the symbol table now contains shared_ptr instead of Symbol, all insert and lookup references had to be modified to accomodate
- Function definitions now use the new 'get_type(...)' method in the Parser, rather than the naive single-lexeme type approach
- The 'Definition' class was modified for the new approach; it now contains and vector of 'SymbolQuality' called 'qualities', as well as a subtype and the appropriate methods to fetch those members and the appropriate modifications to the constructor
- FunctionSymbol now contains the appropriate qualities and subtype for the function symbol due to the modifications to the Definition class

--------------------------------------------------------------------------------------------

5/3 commit to Compiler

- Added a void function 'Compiler::handle_declaration(...)' to add the symbol declared by the 'decl' keyword to the symbol table
- Added support for initial values in decl statements in the Parser. Note that initial values will be _ignored_ unless they are for default function parameters, so they should not be used in decl statements. In the implementation of the function, the default parameter syntax can then be ignored, as this value only matters for when the function is called (this is assuming that function will not be called in the implementation file with default parameters)
	- For this case, added 'bool is_function_parameter = false' to 'parse_statement' and 'parse_declaration'; if this is _false_, the parser will generate an error for alloc-assign syntax in decl statements outside of function parameters
- Modified 'Compiler::call(...)' so that formal parameters are casted to the proper type (if they are allocations, cast to Allocation*; if they are declarations, cast to Declaration*)
- Moved functions to generate the asm for assignment functions to their own implementation file 'Assign.cpp'
- General maintenance including removing unused headers, updating comments, etc.

--------------------------------------------------------------------------------------------

5/2 commit to Compiler

- Moved implementations of functions to parse statements and expressions into their own respective files, 'ParseExpression.cpp' and 'ParseStatement.cpp'

--------------------------------------------------------------------------------------------

4/30 commit to Compiler

- Added 'DECLARATION' to enumerated type 'stmt_type'
- Added and implemented 'Declaration' as a child class of 'Statement'; this is to be used to add header-like functionality into SIN (allowing symbols to be added to a file's symbol table without a corresponding implementation -- this allows the implementation of such symbols to be located in compiled SIN files).
- Added a function 'Parser::get_type()' that returns an instance of the struct TypeData, which keeps track of the type, subtype, array size, and qualities of a variable.
- Parser::parse_allocation(...) now uses the newly added Parser::get_type() function to get the data type of the allocated variable. This resulted in large code refactorings.
- Added a 'MissingSemicolonError' exception, inherited from 'ParserException'; this is used by the Parser for missing semicolon errors, because they appear fairly frequently in the source (the only parameter is the line number). This required making members of 'ParserException' protected instead of private

--------------------------------------------------------------------------------------------

4/29 commit to VM

- Expanded the ALU class, implementing the DIV instructions
- Added an "undefined" flag in the STATUS register to signal the result of an expression is undefined (e.g., if a division by zero is attempted)
- Added and began implementation of an 'Interrupt' flag in the STATUS register; this may be eliminated/replaced in future if it does not get used
- Updated some occurrences of 'int' in the SINVM to 'uint16_t' (built-in 'int' type is not necessary for the VM, as it is a 16-bit machine and unsigned values are represented with two's complement in a 16-bit word)

--------------------------------------------------------------------------------------------

4/7 commit to VM

- Began splitting the SINVM's implementation across multiple source files for organization purposes
- Added SINVM_INT_MIN and SINVM_INT_MAX constants, for future use in the compiler
- Previously, SINVM exceptions did not display the hexadecimal prefix (0x) before the address of the PC when the exception occurred; this has been modified
- Added a StatusConstants namespace to contain numeric constants for the various bit positions of the flags in the STATUS register
- All bit-manipulation functions in the VM now throw exceptions if the function is called using an invalid flag
- Added an ALU class, to be used by the SINVM for all mathematical and logical functionality
- Updated the addition, subtraction, multiplication, and division algorithms to use the N, V, Z, and C flags appropriately
- ADDCA and SUBCA actually /use/ the carry now, unlike before:
	- The carry flag (C) is _always_ used in these instructions, so it is necessary to clear/set (addition/subtraction, respectively) before operations that do not want to take a carry or borrow operation into account; when working with 32-bit integers (instead of 16), this is only done once. However, since 32-bit addition and subtraction have not been implemented in the compiler, this is a moot point for now
- Modified all occurrences of the ADDCA and SUBCA instructions to include appropriate CLC/SEC instruction

--------------------------------------------------------------------------------------------

4/4 commit to Compiler

- Fixed a bug that would cause errors in the parser if the block in a while statement was empty; this was the same problem faced in empty if/else blocks, and has been resolved
- Empty statement blocks in loops or conditions generate compiler warnings
- Fixed a bug that would cause stack corruption in while loops; a single call to Compiler::fetch_value(...) did not pass max_offset as a parameter, which caused the fetch_value function to think the max offset was 0 when it may have been higher. This caused the compiler to fetch and assign values to incorrect places in while loops, which caused data corruption. This has been amended by passing max_offset to fetch_value
- Removed some checks for max_offset's validity in the Compiler::compile_to_sinasm(...) function; since it is no longer a pointer, but rather a value, we don't need to check to see if it is a nullptr
- Added a way to initialize an empty statement of type STATEMENT_GENERAL
- Added a "pass" statement to the language; these will not be turned into any code by the compiler, and is equivalent to a NOOP in assembly or a pass statement in Python. The compiler will generate a warning if it finds any empty statements, so putting pass statements in a program will cause compiler warnings (but not errors)
- 'unsigned int line_number' and 'size_t max_offset' are no longer default parameters in the Compiler::fetch_value(...) function. The call to fetch_value in Compiler::return_value(...) passes in 0, as it passed in nothing before. This may be changed in the future if it ends up causing problems
- Updated the SINVM::push_stack(...) and SINVM::pop_stack() functions; updated data types (from int to size_t or uint16_t) and cleaned up the data writing functions in order to make it easier to understand how they work. These functions may be updated so that reading from a location in the stack can be understood in big-endian format, rather than little endian. For example:
		$23FF: $04
		$23FE: $00
	Pulling from the stack will cause no problem; it creates a word ($23FF)($23FE); if you try to do something like
		loada $23FE
	or
		loada $23FF
	there will be an error; the former will reverse the bytes, as it will create a byte ($23FE)($23FF), which is backwards from how a pull instruction does it; the latter will try to create a word using ($23FF)($2400)
	The reason it works as it currently does it due to the fact that the stack grows downwards.

--------------------------------------------------------------------------------------------

4/1 commit to Compiler

- String concatenation with string array indexing is now supported. Previously, there was no check in the tree evaluation for the right side to allow for indexed expressions, so the right value was never fetched. This resulted in a concatenation of the first value onto itself, as the register values were never updated. This has been resolved.
- Local strings can now be indexed in addition to globals.

--------------------------------------------------------------------------------------------

3/30 commit to Compiler

- Added support for string arrays in both local and global scopes
- Added a "safe reallocation" syscall in the SINVM that will allocate a new dynamic object if it cannot find the dynamic object specified; this is used in string arrays, but nothing else at this point

--------------------------------------------------------------------------------------------

3/29 commit to Compiler

- Updated README.md
- Removed some TODO comments that have already been addressed (or are otherwise no longer necessary) and updated some other existing ones
- Added "DataWidths.h", to allow references to the widths of different data types (in bytes) without hard-coding them; this makes the code more maintainable and more readable
- Updated the Compiler::string_assignment(...) function to modify stack offsets properly; previously, it was not adjusting the stack offset after calling __builtins_memcpy, which makes three pulls from the stack. As such, the compiler _thought_ the offset was three greater than it actually was, resulting in stack underflows when the .sml file was executed. This has been fixed.
- Fixed many bugs in Compiler::move_sp_to_target_address(...):
	- Fixed a typo that moved the stack pointer to A, adjusted it, and then failed to move it back, resulting in the stack pointer never being moved, which caused corruption with local variables. This has been fixed.
	- One of the conditions in the aforementioned function did not update the stack offset, which resulted in further stack data corruption. This has been fixed.
	- When the difference between locations the SP needs to move is more than three words, it uses the TSPA/ADDCA/TASP instructions; there were a few issues with the way this was being done before:
		- It was previously moving the SP by _bytes_ when it should have been moving it by _words_, which resulted in stack data corruption. This has been resolved.
		- It was adding and subtracting incorrectly -- although we were using INCSP and DECSP correctly, we were inverting the uses of ADDCA and SUBCA. This has been resolved

--------------------------------------------------------------------------------------------

3/27 commit to Compiler

- Fixed a parser bug that caused the program to crash when a value returning function call was used as a part of another expression (not in all cases, but some, particularly when the call was followed by an operator). This was due to the value returning expression being returned without being passed into the maybe_binary function, as all expressions are supposed to. This change fixed the issue.
- Fixed a bug in parsing if/else statements that caused bugs when one of the blocks was empty. This has been resolved through skipping closing curly braces only if the statement was not empty; otherwise, we eat through one too many tokens and get errors
- Added stack fixes into function calls for default arguments
- Fixed a bug in the SymbolTable::lookup(...) function that returned wrong symbols; if the symbol was found in a different scope, it might return it, which is incorrect (unless that scope is global). The first check (that avoids dereferencing a nullptr) was modified so that it checks to see if the symbol name and scope are the same, or if the symbol is in the global scope
- Added stack tracking fixes in the string assignment function; the compiler now tracks where it should be in the stack as it does it (as it should) rather than updating it all at the end. Because the stack is used for it, the tracking mechanisms must be updated
- ITE statements can now evaluate binary conditions (instead of literals and unaries only)
- Added a fix to assignments through pointer dereferencing; the compiler previously attempted to fetch a dereferenced value twice, which resulted in any assignments to a dereferenced value becoming corrupted--rather than assigning the appropriate value, it would fetch the target address and then write that. This has been fixed; pointers (at least through two levels of dereferencing) work properly.
	- Note, however, that if an _initial_ assignment is made through a pointer, it does not mark the variable being pointed to as defined, so references to it will generate compiler errors.

--------------------------------------------------------------------------------------------

3/21 commit to Compiler

- Implemented default parameters in function definitions. Like C, they must be declared last, and all parameters are assigned as declared. That is to say, if you have three default arguments, and you pass in 2, it will assign the first two parameters and the third will be the default
- Began reorganization process; code is now organized in a few separate folders:
	- assemble: contains the Assembler class
	- compile: contains:
		- the Compiler class and its implementation; began splitting implementation across multiple files for readability
		- the Symbol class and its implementation; since it's only used by the compiler, it is appropriate for it to be located here
		- the SymbolTable class and its implementation; like Symbol, it is only used by the compiler, making it appropriate to keep with the compiler
	- link: contains the Linker and LinkerSymbol classes
	- parser: contains the SIN Lexer and Parser, including the Statement and Expression classes
	- util: contains various files that are used by multiple classes within the toolchain. Included here are things like the SinObjectFile class, used by the assembler and linker, the BinaryIO library, our custom Exceptions, our Addressing Mode Constants, our VM Memory Map, and the Enumerated Types
- Refactored functions. There were many bugs relating to the stack that have been fixed; previously, it was possible for the function to push function arguments to the wrong part of the stack and call the function so that the arguments pulled were not the ones intended for the function. This was a result of the compiler not updating its stack offset when functions were called or when values were retrieved for an argument.
- The binary tree evaluation now updates the stack offset as well so that it can accurately fetch values from the stack. Without the updates to the stack offset and the max offset, it won't be able to reliably retrieve values from the stack. This is not a problem when dealing with global variables, but it becomes a problem once inside of a function, a conditional block, or a loop block
- Updated comments

--------------------------------------------------------------------------------------------

3/20 commit to Compiler

- Fixed parser bug that did not properly parse if/else statements; when an else clause was present, caused an error. This was due to the parser checking whether the _current_ token was 'else', when it should have been using the 'peek' function.
- Eliminated unused variable Compiler::_DATA_PTR -- its original purpose was to track where variables should go, but this is not the compiler's job and so it was never used.

--------------------------------------------------------------------------------------------

3/18 commit to Compiler

- Compiler functions no longer take 'size_t* stack_offset' as an argument; it is now a member variable of Compiler because it is used so often.
- Void functions are now required to have a return statement -- this may either be "return" or "return void". The 'return' statement is what unwinds the stack, and so failing to include one will result in data corruption. The compiler will generate a warning if the last statement is a function is not a return statement, but not if no return statement is present.
- Fixed a parser bug that didn't correctly parse conditionals without 'else' clauses
- Fixed logical errors in the SINVM mult and div instructions. Previously, it was treating numbers as signed as long as ((A == signed ) && (B == signed)) evaluated to false; that means if the sign bit in both numbers were clear, it treated the result as signed (essentially because we were using OR logic, not XOR logic). This has been resolved; the result is treated as unsigned as long as the sign bits in both A and B match. If they do not, this means only one number is signed, so we have to perform two's complement.
- Further, some boolean comparisons needed parens in the SINVM mult/div instructions due to precedence rules that were overlooked.

--------------------------------------------------------------------------------------------

3/17 commit (3) to Compiler

- Changed the algorithm to evaluate binary trees to start evaluation from the left side rather than the right; this allows for string concatenation to be done (evaluating from right is fine for integer expressions, but once we start writing data in the buffer, it must be done from left to right if there are more than two or three strings to concatenate together).

--------------------------------------------------------------------------------------------

3/17 commit (2) to Compiler

- The VM now uses list::insert to add items upon dynamic memory allocation instead of using list::push_back and list::sort; this is less computationally expensive (O(n) vs O(n log n)). The heap objects will still be in order of where they are in memory.
- Renamed the input buffer in the VM memory map to be a string buffer instead; this is a little more appropriate as it is a buffer for working with strings.
- Implemented string concatenation. The compiler uses the string buffer for this purpose, utilizing __builtins_memcpy to copy each part of the binary tree into the buffer before copying the buffer back into the variable.
	- Note there is still a bug if there are more than two arguments in concatenation. This will be resolved in the next commit.
- Fixed a bug in dynamic reallocation; accidentally used < in a comparison to _HEAP_MAX when it should have been <=
- Added a feature to VMExceptions that includes the state of the STATUS register

--------------------------------------------------------------------------------------------

3/17 commit to Compiler

- Merged Arrays into Compiler
- Implemented dynamic memory reallocation
- Compiler::string_assignment() no longer allocates a new string every time; if the string has already been allocated (Symbol::allocated), it uses the reallocate syscall.

--------------------------------------------------------------------------------------------

3/14 commit to Arrays

- Updated precedence vector to reflect changes to the tokens and operators list
- Updated the translate_operator function (in Expression.cpp) to reflect changes to the operators; further, modified code to avoid aborting the 'for' loop and returning NO_OP at the end of the function only if the loop is never aborted
- Added mult, multu, div, and divu instructions to the VM for multiplication and division; as such, removed __builtins_mult and __builtins_div from the builtins-sinasm16 library.
- In order to determine whether a value is signed or not (as it needs to know for mathematical operations), 'SymbolQuality' now has 'SIGNED' and 'UNSIGNED' qualities. This allows us to determine what instructions to use / how to proceed based on whether we need to treat data as signed or not
- Added a function to the compiler to determine whether an expression is signed:
	- For ints, if the quality is not specified, it's signed
	- Floats are always signed
	- Literal ints are only signed if they are < 0
- Note that although right now, signed/unsigned ints are all treated as the same type, it may be easier to implement separate signed int/unsigned int types if it is the only type that can be unsigned
- Added a 'compiler_warning' function to print a compiler warning -- these are things encountered in compilation that will not stop compilation, but could cause undefined bevahior if they aren't handled (things like signed/unsigned mismatches will go here)
- Fixed parser bug that would crash program if there was an empty function definition; it now prints a warning, but still parses. The compiler will also print a warning if it comes across an empty function definition

--------------------------------------------------------------------------------------------

3/9 commit (2) to Arrays

- Designed compiler schemes to fetch and assign indexed variables
	- Added comments to explain how these algorithms work
- Added _RS_END marker to the VM Memory Map and updated the reference to the _RS data section in the Linker (this way, whenever the VM Memory Map is updated or changed, the linker will still be able to link files using the proper map)
- Updated SINC format to include the symbol width in the symbol table data (_sy_width)
- Updated the builtins library to use the new @rs syntax
- Arrays may now not hold other arrays or structs; however, they may hold pointers to such objects. Arrays may also not use alloc-assign syntax for the time being
- Began process of removing unnecessary variables; most of this happens in the SinObjectFile, Linker, and Assembler classes in reference to symbol, relocation, and data table members. Now that structs are being used for such data, some variables used by these classes are unnecessary and will be removed.
- Modified the SINVM::_debug_values function to display the first page of the stack beneath the memory data

--------------------------------------------------------------------------------------------

3/9 commit to Arrays

- Updated Assembler, SinObjectFile, and Linker to use 'typedef struct' for the symbol, data, and relocation tables rather than tuples. Tuples were a poor choice for the task and structs are far more appropriate. They make the code easier to read, less error-prone, and more maintainable.
- Some initial array implementation; this is far from complete and will be improved and expanded upon in further commits to this branch.
- Removed 'CompilerException' from the repository; the files were unused as such exceptions are now in the 'Exceptions' files.
- The SINASM @rs directive now requires the number of bytes to reserve for the given macro
- Fixed a bug in SINASM that occurred when using indexed addressing with labels; the comma (because commas are required in the indexed addressing syntax in SINASM) was being pushed as a part of the symbol name to the relocation table, so the linker threw an error when it couldn't find the appropriate symbol to match. Now, the assembler removes said comma before pushing to the relocation table, and the error has been fixed.

--------------------------------------------------------------------------------------------

3/4 commit to Compiler

- The parser will now throw exceptions when:
	- It doesn't see an = sign in an assignment
	- The ends of allocation statements don't end with a semicolon, comma, or closing paren (the latter are for function definitions)
- Added an 'AssemblerException' class; replaced runtime_error in Assembler class with this exception
- The 'RAW' type no longer requires (or accepts, for that matter) the size of the raw variable; it defaults to the word size of the machine. In future, it will accept "short" and "short short" (or "long" and "long long") to modify its size
- Added a 'sizeof' expression type to return the size (in bytes) of a type
- Implemented the 'short' addressing mode in the Assembler and SINVM to address a single byte of the memory, rather than a whole word (used for load/store instructions only at the moment)
	- Updated the __builtins_memcpy subroutine to use _bytes_ rather than _words_ for length of memory to copy
	- Added mirrored addressing modes for the short types (i.e., absolute is 0x00, short absolute is 0x10; x indexed is 0x01, short x indexed is 0x11)

--------------------------------------------------------------------------------------------

3/2 commit to Compiler

- Merged Dynamic-Memory into Compiler and deleted the former
- The software is now licensed under the MIT License
- Removed scope information from the 'Statement' class; they were unused and unnecessary
- Input data can no longer cause a buffer overflow into the stack; if the input data is larger than the input buffer, the VM will only copy in as many bytes as are available to the buffer.
- Fixed error where the program threw an std::vector exception when certain lines went unfinished; the Parser::next() and Parser::peek() methods checked to see if the position was <= to the size of the token list when they should have only checked to see if it was <
- Empty tokens are now deleted from the tokens list when the Parser is initialized with a Lexer object
- The SymbolTable::lookup(...) and SymbolTable::is_in_symbol_table(...) functions previously only looked for symbols with the same name that were /also/ in the same scope; the functions now look at lower scopes as well
- Added 'bool SymbolTable::exists_in_scope(...)' to check to see whether a given variable exists in the specified scope at the specified scope level; this is used by the 'SymbolTable::insert(...)' function to check and make sure we don't have duplicates. This is different from SymbolTable::is_in_symbol_table because the latter simply checks to make sure we aren't going to be looking up a symbol that doesn't exist.
- Added "SymbolTableException" class
- Added "line number" as a parameter to the SymbolTable::insert functions; added line numbers to calls for SymbolTable::insert(...) in the Compiler class
- Minor updates to some of the /Doc files

--------------------------------------------------------------------------------------------

2/28 commit (2) to Dynamic-Memory

- Moved the "Symbol" struct to its own file, which is included in the project through the SymbolTable files.
- Began process of adding comment headers to each of the files with short descriptors of what the files' purposes are.
- Changed more exceptions from runtime_error to an exception of the appropriate type (currently using error code 0 as a placeholder)
- Dynamic memory can now be freed using the "free" keyword
	- 'Statement' now contains a 'FreeMemory' statement type
	- The Parser can now parse 'free ...' statements
	- The Compiler can generate assembly for such statements
	- Note that nothing is automatically freed right now and strings must be freed manually (they are _always_ dynamically allocated)
- Reserved a few more keywords for things that will be implemented in future commits (such as arrays and structs)

--------------------------------------------------------------------------------------------

2/28 commit to Dynamic-Memory:

- Implemented global and local strings, both of which can be used in function calls.
	- Currently, the string memory is not freed and there is no mechanism for strings to be reallocated when necessary. Automatic memory reallocation must be expanded and refactored, alongside compiler refactoring, to allow strings to be automatically reallocated when their size expands beyond the space initially allocated for it. Further, the compiler still needs a mechanism to automatically free string memory when they go out of scope.
	- The compiler and parser also need methods to free memory and dynamically allocate memory beyond strings.
- Updated the Compiler::call method to be cleaner and more maintainable, in particular in the way function arguments are pushed to the stack, especially differentiating between static/automatic and dynamic memory.
- Modified the Compiler::incsp_to_stack_frame method to be far more general and flexible; it moves the stack pointer to a particular offset, not just the end of the stack frame.
- Added a string assignment function to handle initial assignments to strings.
	- It must be updated so that it does not reallocate memory for each assignment, and only reallocates the string when necessary.
- Fixed a small bug in the compiler where the string length was not correctly loaded from the heap; it treated certain data as a double-reference pointer when it was only single-reference. The change was from using indirect indexed addressing to plain indexed.
- The VM now forbids writing data into address 0x00; this is so that null pointers will always be guaranteed to return 0x00.
- Added more comments, made further minor fixes to code and readability

--------------------------------------------------------------------------------------------

2/21 commit to Dynamic-Memory:

- 'int main(...)' now supports command-line arguments; no longer throws exceptions when they are supplied
- Began implementation of string support in compiler through the newly-added dynamic memory allocation
- Added an 'INCB' instruction to the VM's instruction set; there is no corresponding 'DECB' instruction
- Added a '__builtins_memcpy' subroutine to 'builtins-sinasm16' and a corresponding SIN wrapper for the memcpy(...) function.
- Fixed an error in the Exceptions wherein error messages from 'what()' were not printed; this was due to a pointer invalidation as a result of using variables in the virtual function, which were destroyed by the time the function was invoked. Moving all message constructions into the constructor for the exception solved this issue.

--------------------------------------------------------------------------------------------

2/20 commit to Dynamic-Memory:

- Added a 'DynamicObject' class, to be used by the VM to store information about dynamic objects, and added a list of such members to the VM
- Added the syscall instructions necessary for reserving VM Heap memory
	- See syscall.txt for information on how they work
- Updated the VM memory map with new address spaces and names
- Fixed data bug in Assember that caused it to write incorrect data for addresses
- 'syscall #$14' no longer encloses the output string in double quotes
- AddressingModeConstants includes <cinttypes>, not <iostream> for the uint__t types
- Other minor edits, fixes, and commenting

--------------------------------------------------------------------------------------------

2/20 commit to Compiler:

- Changed github username, so made changes in the code to reflect that (where github was mentioned).
- Changed SINVM registers from 'int' to 'uint16_t' -- this more accurately reflects how the inner workings of this processor are supposed to be.
- Removed old 'Assembler::disassemble()' code, as the .sinc format has changed since that code was written and the disassemble code was never updated. The function will be rewritten in a future commit.
- Refactored some of the code to make initial assignments to constants. It is still incomplete but will be completed in future commits.
- Added a 'CompilerException' class; all compiler exceptions will be modified to this type in future.
- Began implementation of a 32-bit (single precicion) float type, though this may be changed to 16 bits (half-precision) depending on how it is ultimately implemented in the VM.
- Moved the various enumerated types into their own file for better maintainability / overall organization.

--------------------------------------------------------------------------------------------

2/17 commit to Compiler:

- Fixed more bugs in the builtins mathematical functions and implemented signed multiplication
	(bugs being not getting the correct number when multiplying)
- Fixed a bug in the SINVM code that resulted in an incorrect number being outputted in the load_data_from_memory() function -- switched from a for loop with one index variable to a while loop with 2, which solved the issue
- Fixed some bugs relating to pointers in the compiler -- specifically:
	1) the compiler would report a type match error when the rvalue of an assignment had a pointer in it (specifically in binary rvalue expressions)
	2) the compiler could not properly use dereferenced pointer values as it did not distinguish between pointers and non-pointer lvalues; it can now properly make such references as the indirect addressing modes exist in the assembler
- Fixed pointer dereferences in Parser -- double-ref pointers ended up breaking in the Parser; this is no longer the case, as the method implemented here seems to be more robust than the previous way
- Refactored the Parser to use many functions instead of a single large one to parse statements
- Changed the "lvalue" variable under Statement::Assignment to be a shared pointer rather than an LValue; this allows the left hand expression to be a dereferenced pointer
- Implemented indexed indirect and indirect indexed addressing modes in the VM
- Added an 'f' flag in the STATUS register to indicate a floating point number
- Cleaned up code, added more comments
- Addressed some of the compiler warnings, particularly those about signed/unsigned mismatches (there was a discrepancy between types -- most notably, comparing size_t and int)

Notes:
	- The code currently cannot handle double ref pointers; this is something that will be added in future. Single ref pointers are OK so far
	- There are yet more bugs to fix and there will always be more code to clean up; future commits will include more fixes, refactoring, and comments
	- The 'builtins' functions for mathematics are not yet complete; the library will be expanded in future commits
	- The main function is inefficient and the current methods for use of flags do not work if you wish to use multiple at a time; the main function will therefore be refactored in a future commit to be more modular and efficient.

--------------------------------------------------------------------------------------------

2/15 commit to Compiler:

- Began process of implementing mathematical functions via the 'builtins' library
- There was previously a bug where labels were not given the correct address upon assembly; this was due to an oversight in the code where using a register addressing mode would increment the byte counter too far (instead of incrementing it two bytes for 'ADDCA B', it would add the wordsize on top, resulting in overshooting the destination by 2 bytes per register-operand instruction). This has been fixed.
- Began process of implementing binary tree evaluation, though it is far from complete. There are still many known bugs and incomplete sections of the code.

--------------------------------------------------------------------------------------------

2/13 commit to Compiler:

- Implemented preliminary code to compile if/then/else (ITE) statements
- Added a routine to handle unary expression evaluation
- Added 'sen' and 'cln' (set negative and clear negative) opcodes into SINASM
- Modified some operations within the SINVM to set flags when said operations are performed (e.g., addition can now set the N flag)
- Local variables are now assigned correctly in the assign function -- rather than using the symbol name, it uses the stack (as it is supposed to)
- Branching to an ITE now updates the scope name to be __ITE_<branch number>
- If branches can now be created without an accompanying else branch in the compiler
- More comments and minor other fixes

--------------------------------------------------------------------------------------------

1/21 commit to Compiler:

- There was a previously unknown bug in the Parser wherein dereferenced pointers would result in errors if they were a part of a binary tree. This has been resolved; in parseExpression, we were returning the dereference object directly rather than passing it into maybeBinary, which is what we should have been doing.
- Refactored the compiler's assignment routine to use our new function to fetch values. Note that pointers and dynamic memory types have not yet been implemented.
- More comments and minor other fixes.

--------------------------------------------------------------------------------------------

1/17 commit to Compiler:

- Because gcc/g++ does not support 'std::exception' initialized with a string or char*, all instances of "throw std::exception(" ... ")" were changed to "throw std::runtime_error("...")" for cross-compiler support.

--------------------------------------------------------------------------------------------

1/16 commit to Compiler:

- Added support in assembler for indexed indirect addressing modes alongside indirect indexed; syntax is the same as in 6502 assembly
- Refactored the data type system to support primary- and sub- types alike; this included major changes to the Interpreter as well as some changes in the Expression and Statement classes
- Changed Interpreter's symbol table system to use a 'typedef struct' for symbols instead of 'std::tuple'
- Made some changes to begin the project of dynamic memory management in the compiler/assembler/etc.; non-const-qualified strings will require dynamic memory on the heap, whereas the current system supports only static/const memory
- Removed some old and unnecessary code

--------------------------------------------------------------------------------------------

1/14 commit to Compiler:

- Renamed the namespace 'addressmode' to 'addressingmode' as it is more accurate/consistent
- Refactored statement::type and expression::type to use enums instead of strings; this allows for code that makes much more sense to read, as well as a much more limited range of choices for the types of statements and expressions we can use (e.g., no more wondering if it is "lvalue" or "LValue", as it is LVALUE)
- Began adding in support for a "builtins" library in the compiler (built-in functions will not be hard-coded in the compiler, but use assembly implementations in separate files that are included in projects)
- Added a vector of already-included libraries so we can avoid duplicate dependencies, though it is not yet fully implemented or well-tested
- Added more compilation routines, though they are nowhere close to finished and the compiler remains largely incomplete
- Many more comments
- Began work to make the functions more modular and maintainable
- Fixed typos
- Removed some unnecessary stuff
- Changed comments from # to // in SIN
- Added "asm<>" keyword for inline ASM; note this is NOT protected and the compiler essentially ignores what you do inside
- Updated the included "BinaryIO" library to its latest version

According to "cloc", the project now contains approximately:
	- 5600 lines of code
	- 1700 comment lines
	- 1600 blank lines

--------------------------------------------------------------------------------------------
1/5 commit to Compiler:

- Added constants for the addressing modes in assembler/SINVM. Now, address modes can be referenced by addressmode::___ instead of a number. This makes for less obfuscated and more maintainable code.

- Added beginning to the compiler. Currently capable of producing simple allocations and assignments (literals only) as well as function definitions.

- Modified the 'lexeme' typedef to be a 'typedef struct' instead of an alias for tuple<string, string>. As such, all references to lexemes were modified (and are now much more readable and maintainable). Further, 'int line_number' was added so that the line number where the lexeme was found is included.

- Added a line counter to the Lexer; every time we call next(), if the character is \n, the counter is incremented.

- Added a line number variable to the Statement class, which uses the line number of the first lexeme in the statement to determine the line on which the statement occurred. This allows the compiler to show what line errors occurred on.

--------------------------------------------------------------------------------------------
12/31 commit to Assembler-Directives:

- Changed assembler labels; they no longer begin with "." unless it is a sublabel. Sublabels are always in reference to the most recent "global-level" loop above them. For example:
	MyLabel:
		... 
	.loop:

This will create two labels in the symbol table:
	MyLabel
	MyLabel.loop
Referencing .loop underneath "MyLabel" will look for "MyLabel.loop".

- Because of this, the "is_label()" function was modified to look for a colon at the end of the label rather than a period at the start.

- Added macro support. While label and constant values will be updated by the linker, macro values will not; this is because macro values, when set, are set to a specific value. As such, they should remain unchanged. This is achieved through the sue of another symbol class, "M"

- Modified the values corresponding to the various symbol classes.

--------------------------------------------------------------------------------------------

12/28 commit to Assembler-Directives:

- Updated main program so that it's cleaner and has better support for flags

- Added processor directives:
	- @db - define a constant
	- @rs - reserve memory space (not fully implemented)
	- @include - include a file

This entailed:
	- Updating the linker and adding "C" and "R" classes
	- Updating the assembler
		- Pass 1 now processes all assembler directives; pass 2 ignores them
		- Pass 1 now does what pass 2 does to parse lines -- it creates an array of strings, delimited by spaces
	- Updating the SinObjectFile class
	- Updating the SINVM

Further:
- Began work on the compiler proper
- Added a SymbolTable class for use in the compiler's symbol tables
- Bug fixes
- More comments
- Added includes to SIN files, which required updating the Lexer and Parser classes

Note there are many "TODO:" comments in the code. One major area of focus next is the disassemble function in the Assembler class; it must be updated to support the new .sinc format. These "TODO:" comments will be addressed in future commits.

--------------------------------------------------------------------------------------------

- "changelog.txt" renamed to "commit_history.txt"

- Changed `uint8_t* PC` to `uint16_t PC`; the program counter now holds a memory address in the VM instead of a pointer to the address within the C++ program. This allows us to use a call stack and more easily move around in our program memory. As such, all control flow instructions were modified.

- All pointers were changed to uint16_t type instead of size_t or uint8_t*

- Added the class that will implement our compiler

- Added a memory map

--------------------------------------------------------------------------------------------

12/19:

- Added changelog file; this file's purpose is to log changes as they are made and to go into greater depth about the changes that were made and /why/ they were made.

- Moved all of the opcode constant definitions into "OpcodeConstants.h", which is included in "Assembler.h". The point of this is to:
	- Declutter the Assembler header file
	- Keep the code more organized and maintainable

- Changed "void SINVM::execute_load(int* reg_target)" to "int SINVM::execute_load()"; there is no good reason to have it modify an integer via pointers when it can just return one. While modifying the integer may be emblematic of some other programming style, there is no point to doing it this way so it was changed to return an int.

- Added more comments to code in order to make it more readable

- Simplified some expressions throughout in an attempt to clean up the code

- Added macro support in the assembler. The assembler will parse all macros in the second pass. Unlike labels, macros cannot be referenced before assignment/declaration (much like variables in SIN). This is because labels get their own pass in the assembler to be added; macros are parsed on the second pass. This allows them to be changed after their use.

- Added a disassemble function. Given a SIN bytecode / compiled SIN file, it will produce a SINASM file of a given name based on the compiled file supplied. Note that labels and macros are NOT preserved.

- Moved the function to load a .sinc file into its own file; because it is referenced by both the Assembler and the SINVM, it should be accessible to both in one file, rather than having duplicate definitions in separate files. And, because no instance of the Assembler is opened within the SINVM, it made the most sense to move it into its own file.
