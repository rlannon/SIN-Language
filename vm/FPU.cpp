/*

SIN Toolchain
FPU.cpp
Copyright 2019 Riley Lannon

Contains the implementation of the FPU class

*/

#include "FPU.h"

// todo: handle floating point errors that may be generated by C++, or implement floating point arithmetic manually (without uint32_t -> float conversion)

uint32_t FPU::combine_registers()
{
	/*
	
	Constructs a 32-bit value from two 16-bit values, REG_A and REG_B, where A contains the most significant bits and B contains the least
	
	*/

	uint32_t left = (*this->REG_A << 16) | *this->REG_B;
	return left;
}

void FPU::split_to_registers(uint32_t to_split)
{
	/*

	Splits a 32-bit value into two 16-bit halves, one in REG_A and the other in REG_B -- opposite of FPU::get_left()

	*/

	*this->REG_A = (to_split >> 16) & 0xFFFF;
	*this->REG_B = to_split & 0xFFFF;

	return;
}

uint32_t FPU::unpack_16(uint16_t to_unpack) {
	/*

	Unpacks a 16-bit floating point number as a 32-bit one

	The exponents have a bias of 15 and 127, respectively; subtract 15 or 127 when determining the actual exponent.
	
	16-bit format is as follows:
		0	00000	0000000000
		S	Exp		Mantissa (11)

	32-bit is as follows:
		0	00000000	00000000000000000000000
		S	Exp (5)		Mantissa (23)

	So the floating point number 12.3 would be:
		16:		0	10010		1000100110
		32:		0	10000010	10001001100110011001101
	Note that converting 16->32 would yield:
		32:		0	10000010	10001001100000000000000
	which is 12.296875, not quite 12.3
	
	*/

	uint8_t sign = (to_unpack & 0x8000) >> 15;
	uint8_t exponent = (to_unpack & 0x7C00) >> 10;	// exponent is 5 bits
	uint16_t mantissa = (to_unpack & 0x3FF);	// mantissa is 10 bits

	// adjust the exponent
	if ((exponent & 16) == 16) {
		exponent -= 15;		// subtract the half-precision bias
		exponent += 127;	// add in the single-precision bias
	}

	// assemble the 32-bit float by putting all the bits together, shifting appropriately
	uint32_t single = 0;
	single |= (sign << 31);
	single |= (exponent << 23);
	single |= (mantissa) << 13;

	return single;
}

uint16_t FPU::pack_32(uint32_t to_pack) {
	// Packs a 32-bit floating point number as a 16-bit one
	uint8_t sign = (to_pack & 0x80000000) >> 31;
	uint8_t exponent = (to_pack & 0x7F800000) >> 23;
	uint16_t mantissa = (to_pack & 0x00FFFFFF) >> 13;

	// adjust the exponent
	if ((exponent & 128) == 128) {
		exponent -= 127;
		exponent += 15;
	}

	uint16_t half = 0;

	half |= (sign << 15);
	half |= (exponent << 10);
	half |= mantissa;

	return half;
}


/*

Half-precision instructions
These functions implement the half-precision floating-point operations, which actually use the 32-bit FPU operations.
The functions unpack the halfs as singles, pass them into the 32-bit functions, and pack them back into 16-bit format.

Since they call the 32-bit functions, the 16-bit ones will not affect the STATUS register, as that will be done by the 32-bit functions
However, the 16-bit functions may affect the STATUS register if the result was unexpected -- for overflow, etc., that may not be caught by 32-bit

todo: since these functions are all almost the same, can we combine their implementations in such a way that they don't need to take up so much space?

*/

void FPU::fadda(uint16_t right) {
	// half-precision addition
	uint32_t left_single = unpack_16(*this->REG_A);		// make this into a function returning a tuple?
	uint32_t right_single = unpack_16(right);

	// split the 32-bit left value in half
	this->split_to_registers(left_single);

	// perform the addition
	this->single_fadda(right_single);

	// re-pack the result
	uint32_t result = (*this->REG_A << 16) | (*this->REG_B);
	*this->REG_A = pack_32(result);

	return;
}

void FPU::fsuba(uint16_t right) {
	// half-precision subtraction
	uint32_t left_single = unpack_16(*this->REG_A);
	uint32_t right_single = unpack_16(right);

	this->split_to_registers(left_single);

	// perform the subtraction
	this->single_fsuba(right_single);

	// re-pack the result
	uint32_t result = this->combine_registers();
	*this->REG_A = pack_32(result);

	return;
}

void FPU::fmulta(uint16_t right) {
	// half-precision multiplication
	uint32_t left_single = unpack_16(*this->REG_A);
	uint32_t right_single = unpack_16(right);

	this->split_to_registers(left_single);

	this->single_fmulta(right_single);

	uint32_t result = this->combine_registers();
	*this->REG_A = pack_32(result);

	return;
}

void FPU::fdiva(uint16_t right) {
	// half-precision division
	uint32_t left_single = unpack_16(*this->REG_A);
	uint32_t right_single = unpack_16(right);

	this->split_to_registers(left_single);

	this->single_fdiva(right_single);

	uint32_t result = this->combine_registers();
	*this->REG_A = pack_32(result);

	return;
}


/*

Single-precision instructions
These functions implement single-precision floating-point operations, opereating on 32-bit values.
The 32-bit left operand is constructed by using the A register as the most significant 16 bits, and the B register as the least significant

*/

void FPU::single_fadda(uint32_t right)
{
	/*
	
	Adds two floating point numbers together, converting the uint32_t types to float first (using reinterpret_cast)

	todo: modify how STATUS register is affected -- C, V flags

	*/
	
	// get the left-hand value from REG_A and REG_B
	uint32_t left = this->combine_registers();
	
	// convert to float, perform operation
	float* left_f = reinterpret_cast<float*>(&left);
	float* right_f = reinterpret_cast<float*>(&right);
	*left_f += *right_f;

	if (*left_f == 0) {
		*this->STATUS |= StatusConstants::zero;
	}
	
	// split the value back into registers and set the F flag
	this->split_to_registers(*reinterpret_cast<uint32_t*>(&left_f));
	*this->STATUS |= StatusConstants::floating_point;	// set the floating-point flag

	return;
}

void FPU::single_fsuba(uint32_t right)
{
	// single-precision subtraction

	uint32_t left = this->combine_registers();	// get the left-hand value

	float* left_f = reinterpret_cast<float*>(&left);
	float* right_f = reinterpret_cast<float*>(&right);
	*left_f -= *right_f;

	if (*left_f == 0) {
		*this->STATUS |= StatusConstants::zero;
	}

	this->split_to_registers(*reinterpret_cast<uint32_t*>(&left_f));
	*this->STATUS |= StatusConstants::floating_point;

	return;
}

void FPU::single_fmulta(uint32_t right)
{
	// single-precision multiplication

	uint32_t left = this->combine_registers();	// get the left-hand value

	float* left_f = reinterpret_cast<float*>(&left);
	float* right_f = reinterpret_cast<float*>(&right);

	*left_f *= *right_f;

	if (*left_f == 0) {
		*this->STATUS |= StatusConstants::zero;
	}

	this->split_to_registers(*reinterpret_cast<uint32_t*>(&left_f));
	*this->STATUS |= StatusConstants::floating_point;

	return;
}

void FPU::single_fdiva(uint32_t right)
{
	// single-precision division

	uint32_t left = this->combine_registers();	// get the left-hand value

	float* left_f = reinterpret_cast<float*>(&left);
	float* right_f = reinterpret_cast<float*>(&right);
	
	if (*right_f == 0) {
		*this->STATUS |= StatusConstants::undefined;
		return;
	}
	else {
		if (*left_f == 0) {
			*this->STATUS |= StatusConstants::zero;
		}

		*left_f /= *right_f;

		this->split_to_registers(*reinterpret_cast<uint32_t*>(&left));
		*this->STATUS |= StatusConstants::floating_point;

		return;
	}
}


/*

Constructor / Destructor

*/


FPU::FPU(uint16_t* REG_A, uint16_t* REG_B, uint8_t* STATUS): REG_A(REG_A), REG_B(REG_B), STATUS(STATUS) {
	
}

FPU::FPU() {
	// initialize the pointers to nullptr in the default constructor
	this->REG_A = nullptr;
	this->REG_B = nullptr;
	this->STATUS = nullptr;
}

FPU::~FPU() {

}
